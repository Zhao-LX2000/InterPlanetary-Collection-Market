// Code generated by hertz generator.

package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/IPAM/kitex_gen/artwork"
	ipamfile "github.com/IPAM/kitex_gen/file"
	testuser "github.com/IPAM/kitex_gen/testUser"
	consts2 "github.com/IPAM/pkg/consts"
	"github.com/IPAM/pkg/errno"
	"github.com/IPAM/server/api/dboperation"
	api "github.com/IPAM/server/api/model/api"
	"github.com/IPAM/server/api/mw"
	"github.com/IPAM/server/api/rpc"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	shell "github.com/ipfs/go-ipfs-api"
	"github.com/jlaffaye/ftp"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"strconv"
	"strings"
	"time"
)

// CreateUser .
// @router /v1/user/register [POST]
func CreateUser(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.CreateUserRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	err = rpc.CreateUser(context.Background(), &testuser.CreateUserRequest{
		Username: req.Username,
		Password: req.Password,
	})
	if err != nil {
		SendResponse(c, errno.ConvertErr(err), nil)
		return
	}
	SendResponse(c, errno.Success, nil)
}

// CheckUser .
// @router /v1/user/login [POST]
func CheckUser(ctx context.Context, c *app.RequestContext) {
	mw.JwtMiddleware.LoginHandler(ctx, c)
}

// TestToken .
// @router /v1/test/testToken [GET]
func TestToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.TestTokenRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	if err != nil {
		SendResponse(c, errno.ConvertErr(err), nil)
		return
	}
	SendResponse(c, errno.Success, nil)
}

// GetEthBalance .
// @router /v1/artwork/getBalance [GET]
func GetEthBalance(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetEthBalanceRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	payLoad, exists := c.Get(consts2.IdentityKey)

	if !exists {
		fmt.Println("damn fucking not exit")
		SendResponse(c, nil, nil)
	}

	m := payLoad.(map[string]string)
	addr := m[consts2.IdentityKey]

	balance, err := rpc.GetEthBalance(ctx, &artwork.GetEthBalanceRequest{
		Address: addr,
	})

	if err != nil {
		SendResponse(c, errno.ConvertErr(err), nil)
		return
	}

	resp := new(api.GetEthBalanceResponse)
	resp.Balance = balance
	resp.BaseResp = &api.BaseResp{
		StatusCode: consts.StatusOK,
	}

	c.JSON(consts.StatusOK, resp)
	//SendResponse(c, errno.Success, nil)
}

// GetCollectionTokenBalance .
// @router /v1/artwork/getTokenBalance [GET]
func GetCollectionTokenBalance(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetTokenBalanceRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	payLoad, exists := c.Get(consts2.IdentityKey)

	if !exists {
		fmt.Println("damn fucking not exit")
		SendResponse(c, nil, nil)
	}

	m := payLoad.(map[string]string)
	addr := m[consts2.IdentityKey]

	fmt.Println("GetCollectionTokenBalance：the value is", addr)

	//进
	balance, err := rpc.GetTokenBalance(ctx, &artwork.GetOwnerBalanceRequest{
		Address: addr,
	})

	if err != nil {
		SendResponse(c, errno.ConvertErr(err), nil)
		return
	}

	resp := new(api.GetTokenBalanceResponse)
	resp.Balance = balance
	resp.BaseResp = &api.BaseResp{
		StatusCode: consts.StatusOK,
	}

	c.JSON(consts.StatusOK, resp)
}

// BuyCollection .
// @router /v1/artwork/BuyCollection [POST]
func BuyCollection(ctx context.Context, c *app.RequestContext) {
	var err error
	//var req api.BuyCollectionRequest
	//err = c.BindAndValidate(&req)
	//if err != nil {
	//	c.String(consts.StatusBadRequest, err.Error())
	//	return
	//}

	payLoad, exists := c.Get(consts2.IdentityKey)

	if !exists {
		fmt.Println("damn fucking not exit")
		SendResponse(c, nil, nil)
	}

	m := payLoad.(map[string]string)
	addr := m[consts2.IdentityKey]
	fromUser := m[consts2.AccountName]
	//fromuserres, err := rpc.QueryUser(ctx, &testuser.QueryUserRequest{fromUser})
	//fromUserAddr := fromuserres.User.Keystore
	toUser := c.FormValue("toUser")
	fmt.Println(string(toUser))
	touserres, err := rpc.QueryUser(ctx, &testuser.QueryUserRequest{string(toUser)})
	toUserAddr := touserres.User.PublicKey
	cid := c.FormValue("cid")
	acid, err := strconv.Atoi(string(cid))
	fmt.Println("acid")
	fmt.Println(acid)
	file, err := dboperation.QueryFile(ctx, acid)
	if err != nil {
		log.Println(err.Error())
	}
	passw := c.FormValue("pass")
	//调用数据库通过artHash查找价格
	//artHash := req.ArtHash
	val := file[0].Price
	fmt.Println("val")
	fmt.Println(val)
	balance, err := rpc.GetTokenBalance(ctx, &artwork.GetOwnerBalanceRequest{
		Address: addr,
	})

	if err != nil {
		SendResponse(c, errno.ConvertErr(err), nil)
		return
	}

	if balance < int64(val) {
		SendResponse(c, errno.ConvertErr(errno.UnaffordableErr), nil)
		return
	}

	nonce, err := rpc.BuyCollection(ctx, &artwork.BuyCollectionRequest{
		From:     addr,
		To:       toUserAddr,
		ArtHash:  "",
		Password: string(passw),
		Filename: fromUser,
		Value:    int64(val),
	})

	if err != nil {
		SendResponse(c, errno.ConvertErr(err), nil)
		return
	}
	err = dboperation.ChangeOwner(ctx, acid, fromUser)
	if err != nil {
		SendResponse(c, errno.ConvertErr(err), "改变数据库出错")
		return
	}
	resp := new(api.BuyCollectionResponse)
	resp.Nonce = nonce
	resp.BaseResp = &api.BaseResp{
		StatusCode: consts.StatusOK,
	}
	c.JSON(consts.StatusOK, resp)
}
func GetFileList(ctx context.Context, c *app.RequestContext) {
	file, err := dboperation.ListFile(ctx)
	if err != nil {
		SendResponse(c, errno.ConvertErr(err), nil)
		return
	}

	c.JSON(consts.StatusOK, file)
	//SendResponse(c, errno.Success, nil)
}

var sh *shell.Shell

type Rep struct {
	Name  string `json:"Name,omitempty"`
	Hash  string `json:"Hash,omitempty"`
	Size  string `json:"Size,omitempty"`
	Bytes int64  `json:"Bytes,omitempty"`
}

type Reps struct {
	r []Rep
}

func UploadFile(ctx context.Context, c *app.RequestContext) {
	strinUrl := "http://127.0.0.1:4006/api/v0/add?stream-channels=true&pin=false&progress=true&wrap-with-directory=true"
	payLoad, exists := c.Get(consts2.IdentityKey)
	if !exists {
		fmt.Println("name damn fucking not exit")
		SendResponse(c, nil, nil)
	}
	m := payLoad.(map[string]string)
	aut := m[consts2.AccountName]
	client := http.Client{}
	bodyBuf := &bytes.Buffer{}
	bodyWrite := multipart.NewWriter(bodyBuf)
	file, _ := c.FormFile("file")
	workname := c.FormValue("workName")
	workdescription := c.FormValue("workDescription")
	url := c.FormValue("url")
	price2 := c.FormValue("price")
	price, err := strconv.Atoi(string(price2))
	open, err := file.Open()
	fileWrite, err := bodyWrite.CreateFormFile("file", file.Filename)
	_, err = io.Copy(fileWrite, open)
	if err != nil {
		log.Println("err")
	}
	bodyWrite.Close() //要关闭，会将w.w.boundary刷写到w.writer中
	// 创建请求
	req, err := http.NewRequest(http.MethodPost, strinUrl, bodyBuf)
	if err != nil {
		log.Println("err")
	}
	// 设置头
	contentType := bodyWrite.FormDataContentType()
	req.Header.Set("Content-Type", contentType)

	resp, err := client.Do(req)
	if err != nil {
		log.Println("err")
	}

	/************************************************************/

	defer resp.Body.Close()
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Println("err")
	}
	a := string(b)
	fmt.Println(a)
	start := strings.LastIndex(a, "{")
	//end := strings.LastIndex(a, "}")
	a = a[:start]
	start = strings.LastIndex(a, "{")
	end := strings.LastIndex(a, "}")
	var j Rep
	strn := a[start : end+1]
	fmt.Println(strn)
	err = json.Unmarshal([]byte(strn), &j)
	if err != nil {
		log.Println(err.Error())
	}

	// 连接FTP服务器
	ftpClient, err := ftp.Dial("43.136.22.7:21")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer ftpClient.Quit()
	// 登录FTP服务器
	err = ftpClient.Login("ipcmgo", "ipcmgo")
	if err != nil {
		fmt.Println(err)
		return
	}
	get, err := http.Get(string(url))
	defer get.Body.Close()
	// 上传文件
	all, err := io.ReadAll(get.Body)
	timestamp := time.Now().Unix()
	t := time.Unix(timestamp, 0)
	tstr := t.Format("2006-01-02 15:04:05")
	nginxfilename := tstr + "-" + file.Filename
	err = ftpClient.Stor(nginxfilename, bytes.NewReader(all))
	if err != nil {
		fmt.Println(err)
		return
	}
	err = dboperation.AddFile(ctx, []*dboperation.IPFSFile{{
		//暂时写死
		FileName:        file.Filename,
		AuthorName:      aut,
		Owners:          aut,
		WorkName:        string(workname),
		WorkDescription: string(workdescription),
		Hash:            j.Hash,
		Url:             "http://43.136.22.7/images/" + nginxfilename,
		Price:           price,
	}})
	if err != nil {
		log.Println(err.Error())
	}

	c.JSON(consts.StatusOK, j)
}

// UploadCollection .
// @router /v1/file/UploadCollection [POST]
func UploadCollection(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.UploadCollectionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	strinUrl := "http://127.0.0.1:4006/api/v0/add?stream-channels=true&pin=false&progress=true&wrap-with-directory=true"
	payLoad, exists := c.Get(consts2.IdentityKey)
	if !exists {
		fmt.Println("name damn fucking not exit")
		SendResponse(c, nil, nil)
	}
	m := payLoad.(map[string]string)
	aut := m[consts2.AccountName]
	client := http.Client{}
	bodyBuf := &bytes.Buffer{}
	bodyWrite := multipart.NewWriter(bodyBuf)
	file, _ := c.FormFile("file")

	open, err := file.Open()
	fileWrite, err := bodyWrite.CreateFormFile("file", file.Filename)
	_, err = io.Copy(fileWrite, open)
	if err != nil {
		log.Println("err")
	}
	bodyWrite.Close() //要关闭，会将w.w.boundary刷写到w.writer中
	// 创建请求
	req2, err := http.NewRequest(http.MethodPost, strinUrl, bodyBuf)
	if err != nil {
		log.Println("err")
	}
	// 设置头
	contentType := bodyWrite.FormDataContentType()
	req2.Header.Set("Content-Type", contentType)
	resp, err := client.Do(req2)
	if err != nil {
		log.Println("err")
	}
	defer resp.Body.Close()
	b, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Println("err")
	}
	a := string(b)
	fmt.Println(a)
	start := strings.LastIndex(a, "{")
	//end := strings.LastIndex(a, "}")
	a = a[:start]
	start = strings.LastIndex(a, "{")
	end := strings.LastIndex(a, "}")
	var j Rep
	strn := a[start : end+1]
	fmt.Println(strn)
	err = json.Unmarshal([]byte(strn), &j)
	if err != nil {
		log.Println(err.Error())
	}
	_, err = rpc.UploadCollection(ctx, &ipamfile.UploadCollectionRequest{
		Filename:        file.Filename,
		Authorname:      aut,
		Owners:          aut,
		Workname:        req.Collection.Workname,
		Workdescription: req.Collection.Workdescription,
		Hash:            j.Hash,
		Price:           req.Collection.Price,
	})

	if err != nil {
		SendResponse(c, errno.ConvertErr(err), nil)
		return
	}

	resp4 := new(api.GetCollectionListResponse)
	resp4.BaseResp = &api.BaseResp{
		StatusCode: consts.StatusOK,
	}

	c.JSON(consts.StatusOK, resp4)
	//resp := new(api.UploadCollectionResponse)
	//c.JSON(consts.StatusOK, resp)
}

//func UploadFile2(ctx context.Context, c *app.RequestContext) {
//
//	/************************************************************/
//
//	//// 连接FTP服务器
//	//ftpClient, err := ftp.Dial("43.136.22.7:21")
//	//if err != nil {
//	//	fmt.Println(err)
//	//	return
//	//}
//	//defer ftpClient.Quit()
//	//// 登录FTP服务器
//	//err = ftpClient.Login("ipcmgo", "ipcmgo")
//	//if err != nil {
//	//	fmt.Println(err)
//	//	return
//	//}
//	//get, err := http.Get(string(url))
//	//defer get.Body.Close()
//	//// 上传文件
//	//all, err := io.ReadAll(get.Body)
//	//timestamp := time.Now().Unix()
//	//t := time.Unix(timestamp, 0)
//	//tstr := t.Format("2006-01-02 15:04:05")
//	//nginxfilename := tstr + "-" + file.Filename
//	//err = ftpClient.Stor(nginxfilename, bytes.NewReader(all))
//	//if err != nil {
//	//	fmt.Println(err)
//	//	return
//	//}
//	err = dboperation.AddFile(ctx, []*dboperation.IPFSFile{{
//		//暂时写死
//		FileName:        file.Filename,
//		AuthorName:      aut,
//		Owners:          aut,
//		WorkName:        string(workname),
//		WorkDescription: string(workdescription),
//		Hash:            j.Hash,
//		Url:             "http://43.136.22.7/images/" + nginxfilename,
//		Price:           price,
//	}})
//	if err != nil {
//		log.Println(err.Error())
//	}
//
//	c.JSON(consts.StatusOK, j)
//}

// GetCollectionListCollection .
// @router /v1/file/GetCollectionList [GET]
func GetCollectionListCollection(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.GetCollectionListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	log.Println("1调用")
	list, err := rpc.GetCollectionList(ctx, &ipamfile.GetCollectionListRequest{})

	if err != nil {
		SendResponse(c, errno.ConvertErr(err), nil)
		return
	}
	c.JSON(consts.StatusOK, list.Collections)
}
